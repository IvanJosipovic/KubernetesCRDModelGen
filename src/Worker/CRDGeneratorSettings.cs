//using Microsoft.CodeAnalysis.CSharp;
//using Microsoft.CodeAnalysis;
//using NuGet.Packaging.Core;
//using System.Collections.Immutable;
//using Yardarm;
//using System.Reflection;
//using Microsoft.OpenApi.Models;
//using Yardarm.Generation;
//using Yardarm.Packaging.Internal;
//using Yardarm.Enrichment;
//using Yardarm.Generation.Authentication;
//using Yardarm.Generation.MediaType;
//using Yardarm.Generation.Request;
//using Yardarm.Generation.Response;
//using Yardarm.Generation.Schema;
//using Yardarm.Generation.Tag;
//using Yardarm.Packaging;
//using Yardarm.Generation.Internal;
//using Microsoft.Extensions.DependencyInjection.Extensions;
//using Yardarm.Generation.Operation;
//using Yardarm.Names.Internal;
//using Yardarm.Names;
//using Yardarm.Serialization;
//using Yardarm.Spec;
//using Yardarm.Spec.Internal;
//using Yardarm.SystemTextJson;
//using Yardarm.SystemTextJson.Internal;
//using Yardarm.Enrichment.Compilation;
//using Yardarm.Enrichment.Packaging;
//using Yardarm.Enrichment.Schema;

//namespace Worker {
//    public class CRDGeneratorSettings {
//        private Stream? _dllOutput;
//        private Stream? _pdbOutput;
//        private Stream? _xmlDocumentationOutput;

//        private readonly List<YardarmExtension> _extensions = new List<YardarmExtension>();
//        private readonly List<Action<ILoggingBuilder>> _loggingBuilders = new List<Action<ILoggingBuilder>>();

//        public string AssemblyName { get; set; } = "Yardarm.Sdk";
//        public string RootNamespace { get; set; } = "Yardarm.Sdk";

//        public Version Version { get; set; } = new Version(1, 0, 0);
//        public string? VersionSuffix { get; set; }
//        public string Author { get; set; } = "anonymous";
//        public RepositoryMetadata? Repository { get; set; }

//        /// <summary>
//        /// If true, embed generated source code in the symbols PDB file and package. This
//        /// enables stepping into the generated SDK when debugging.
//        /// </summary>
//        public bool EmbedAllSources { get; set; }

//        public Stream DllOutput {
//            get => _dllOutput ??= new MemoryStream();
//            set => _dllOutput = value ?? throw new ArgumentNullException(nameof(value));
//        }

//        public Stream PdbOutput {
//            get => _pdbOutput ??= new MemoryStream();
//            set => _pdbOutput = value ?? throw new ArgumentNullException(nameof(value));
//        }

//        public Stream XmlDocumentationOutput {
//            get => _xmlDocumentationOutput ??= new MemoryStream();
//            set => _xmlDocumentationOutput = value ?? throw new ArgumentNullException(nameof(value));
//        }

//        public Stream? ReferenceAssemblyOutput { get; set; }

//        /// <summary>
//        /// Optional intermediate output path. Typically used to store files useful in incremental builds
//        /// and NuGet restores, such as project.assets.json.
//        /// </summary>
//        public string? IntermediateOutputPath { get; set; }

//        /// <summary>
//        /// Bypass the restore on generation, assume that a restore has already been done using <see cref="IntermediateOutputPath"/>.
//        /// </summary>
//        public bool NoRestore { get; set; }

//        public ImmutableArray<string> TargetFrameworkMonikers { get; set; } = new[] { "netstandard2.0" }.ToImmutableArray();

//        public Stream? NuGetOutput { get; set; }

//        public Stream? NuGetSymbolsOutput { get; set; }

//        /// <summary>
//        /// A list of referenced assembly paths. If null or empty, these will be autogenerated by Yardarm based on referenced
//        /// NuGet packages and frameworks. Typically passed in from MSBuild.
//        /// </summary>
//        public List<string>? ReferencedAssemblies { get; set; }

//        public CSharpCompilationOptions CompilationOptions { get; set; } =
//            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary)
//                .WithDeterministic(true)
//                .WithOptimizationLevel(OptimizationLevel.Release)
//                .WithNullableContextOptions(NullableContextOptions.Enable)
//                .WithOverflowChecks(false)
//                .WithPlatform(Platform.AnyCpu)
//                .WithConcurrentBuild(true)
//                .WithAssemblyIdentityComparer(DesktopAssemblyIdentityComparer.Default)
//                .WithSpecificDiagnosticOptions(new KeyValuePair<string, ReportDiagnostic>[]
//                {
//                    // Don't warn for binding redirects
//                    new("CS1701", ReportDiagnostic.Suppress),
//                    new("CS1702", ReportDiagnostic.Suppress)
//                });



//        public CRDGeneratorSettings AddExtension(Type type) {
//            if (type == null) {
//                throw new ArgumentNullException(nameof(type));
//            }
//            if (!typeof(YardarmExtension).IsAssignableFrom(type)) {
//                throw new ArgumentException($"Type {type.FullName} must inherit from YardarmExtension.");
//            }

//            var constructor = type.GetConstructor(Type.EmptyTypes);
//            if (constructor == null) {
//                throw new ArgumentException($"Type {type.FullName} must have a default constructor.");
//            }

//            _extensions.Add((YardarmExtension)constructor.Invoke(null));

//            return this;
//        }

//        public CRDGeneratorSettings AddExtension<T>()
//            where T : YardarmExtension =>
//            AddExtension(typeof(T));

//        public CRDGeneratorSettings AddExtension(Assembly assembly) {
//            foreach (var type in assembly.GetExportedTypes()
//                .Where(p => p.IsClass && !p.IsAbstract && typeof(YardarmExtension).IsAssignableFrom(p))) {
//                AddExtension(type);
//            }

//            return this;
//        }

//        public CRDGeneratorSettings AddLogging(Action<ILoggingBuilder> buildAction) {
//            if (buildAction == null) {
//                throw new ArgumentNullException(nameof(buildAction));
//            }

//            _loggingBuilders.Add(buildAction);

//            return this;
//        }

//        public IServiceProvider BuildServiceProvider(OpenApiDocument? document) {
//            IServiceCollection services = new ServiceCollection()
//                .AddLogging(builder => {
//                    foreach (var configuredBuilder in _loggingBuilders) {
//                        configuredBuilder(builder);
//                    }
//                });

//            services = _extensions.Aggregate(services, (p, extension) => extension.ConfigureServices(p));

//            services
//                .AddDefaultCompilationEnrichers()
//                .AddDefaultPackagingEnrichers()
//                .AddDefaultSchemaEnrichers();

//            services.AddTransient(typeof(IReferenceGenerator), GetType("NuGetReferenceGenerator"));

//            services.AddSingleton<YardarmGenerationSettings>();

//            // Generators
//            services
//                .AddTransient(typeof(ISyntaxTreeGenerator), GetType("AssemblyInfoGenerator"))
//                .AddTransient<ISyntaxTreeGenerator, ClientGenerator2>()
//                .AddTransient<ISyntaxTreeGenerator, SchemaGenerator>()
//                .AddTransient(typeof(IDependencyGenerator), GetType("StandardDependencyGenerator"));

//            services.TryAddSingleton(typeof(ITypeGeneratorRegistry), GetType("TypeGeneratorRegistry"));
//            //services.TryAdd(new ServiceDescriptor(typeof(ITypeGeneratorRegistry<,>), typeof(TypeGeneratorRegistry<,>), ServiceLifetime.Singleton));
//            //services.TryAdd(new ServiceDescriptor(typeof(ITypeGeneratorRegistry<>), typeof(PrimaryGeneratorCategory.TypeGeneratorRegistryWrapper<>), ServiceLifetime.Singleton));
//            services.TryAdd(new ServiceDescriptor(typeof(ITypeGeneratorFactory<,>), typeof(NoopTypeGeneratorFactory<,>), ServiceLifetime.Singleton));

//            services.TryAddTypeGeneratorFactory<OpenApiSchema, DefaultSchemaGeneratorFactory>();

//            services.TryAddSingleton<IPackageSpecGenerator, DefaultPackageSpecGenerator>();
//            services.TryAddSingleton(serviceProvider => serviceProvider.GetRequiredService<IPackageSpecGenerator>().Generate());

//            // Names
//            services.TryAddSingleton<CamelCaseNameFormatter>();
//            services.TryAddSingleton<PascalCaseNameFormatter>();
//            services.TryAddSingleton<INameFormatterSelector, NameFormatterSelector>();
//            services.TryAddSingleton<INamespaceProvider, DefaultNamespaceProvider>();
//            services.TryAddSingleton<INameConverterRegistry>(_ => NameConverterRegistry.CreateDefaultRegistry());
//            services.TryAddSingleton<IHttpResponseCodeNameProvider, HttpResponseCodeNameProvider>();
//            services.TryAddSingleton(typeof(IRootNamespace), GetType("RootNamespace"));
//            services.TryAddSingleton(typeof(IApiNamespace), GetType("ApiNamespace"));
//            services.TryAddSingleton(typeof(IAuthenticationNamespace), GetType("AuthenticationNamespace"));
//            services.TryAddSingleton(typeof(IRequestsNamespace), GetType("RequestsNamespace"));
//            services.TryAddSingleton(typeof(IResponsesNamespace), GetType("ResponsesNamespace"));
//            services.TryAddSingleton(typeof(ISerializationNamespace), GetType("SerializationNamespace"));

//            // Other
//            services
//                .AddLogging()
//                .AddTransient(GetType("NuGetRestoreProcessor"))
//                .AddTransient<NuGetPacker>();

//            services
//                  .AddSingleton<GenerationContext>()
//                  // When requesting the YardarmContext simply return the GenerationContext
//                  .AddTransient<YardarmContext>(serviceProvider => serviceProvider.GetRequiredService<GenerationContext>())
//                  .AddSingleton(document);

//            services.TryAddSingleton(typeof(IOpenApiElementRegistry), GetType("OpenApiElementRegistry"));

//            return services.BuildServiceProvider();
//        }

//        private Type GetType(string name) {
//            return typeof(Yardarm.YardarmGenerator).Assembly.GetType(name);
//        }
//    }
//}
